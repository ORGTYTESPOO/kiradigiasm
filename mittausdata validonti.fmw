#! <?xml version="1.0" encoding="UTF-8" ?>
#! <WORKSPACE
#    
#    
#    Command-line to run this workspace:
#    
#    
#    "C:\Program Files\FME\fme.exe" "C:\Users\toomeve\Desktop\työ\Kira OH\inframodel\mittausdata validonti.fmw"
#          --SourceDataset_CAT "C:\Users\toomeve\Desktop\työ\Kira OH\inframodel\Tammitie.lis"
#          --SourceDataset_LANDXML "C:\Users\toomeve\Desktop\työ\Kira OH\201000_Ylin yhdistelmapinta_yyp_tammitie.xml"
#    
#    
#!   USE_MARKDOWN=""
#!   TITLE=""
#!   DESTINATION_ROUTING_FILE=""
#!   IGNORE_READER_FAILURE="No"
#!   MARKDOWN_DESCRIPTION=""
#!   LOG_FILE=""
#!   FME_DOCUMENT_GUID="84650f32-1df9-4b8e-a32e-f66f3a2b0404"
#!   SOURCE_ROUTING_FILE=""
#!   LAST_SAVE_DATE="2017-06-14T13:22:22"
#!   DESTINATION="NONE"
#!   DOC_TOP_LEFT="100 -743.004"
#!   SHOW_INFO_NODES="true"
#!   LOG_MAX_RECORDED_FEATURES="200"
#!   FME_STROKE_MAX_DEVIATION="0"
#!   BEGIN_TCL=""
#!   WORKSPACE_VERSION="1"
#!   PASSWORD=""
#!   END_TCL=""
#!   FME_GEOMETRY_HANDLING="Enhanced"
#!   FME_REPROJECTION_ENGINE="FME"
#!   EXPLICIT_BOOKMARK_ORDER="false"
#!   FME_BUILD_NUM="17280"
#!   ATTR_TYPE_ENCODING="SDF"
#!   REDIRECT_TERMINATORS="NONE"
#!   VIEW_POSITION="-96.3355 -23.4965"
#!   CATEGORY=""
#!   SHOW_ANNOTATIONS="true"
#!   FME_SERVER_SERVICES=""
#!   USAGE=""
#!   MARKDOWN_USAGE=""
#!   DOC_EXTENTS="2021.77 513.004"
#!   LAST_SAVE_BUILD="FME(R) 2017.0.0.2 (20170331 - Build 17280 - WIN64)"
#!   PYTHON_COMPATIBILITY="27"
#!   DESCRIPTION=""
#!   WARN_INVALID_XFORM_PARAM="Yes"
#!   BEGIN_PYTHON=""
#!   MAX_LOG_FEATURES="200"
#!   ZOOM_SCALE="133"
#!   SOURCE="NONE"
#!   TERMINATE_REJECTED="NO"
#!   FME_IMPLICIT_CSMAP_REPROJECTION_MODE="Auto"
#!   MULTI_WRITER_DATASET_ORDER="BY_ID"
#!   END_PYTHON=""
#!   HISTORY=""
#!   FME_DOCUMENT_PRIORGUID="b005c644-43b4-4d93-891e-779767e4debb,1460aad9-a0cc-42b2-ad7d-b0a17d0d436b"
#! >
#! <DATASETS>
#! <DATASET
#!   IS_SOURCE="true"
#!   ROLE="READER"
#!   FORMAT="CAT"
#!   DATASET="$(SourceDataset_CAT)"
#!   KEYWORD="CAT_1"
#!   MULTI_GEOM_ALLOWED="false"
#!   ATTR_MAX_LENGTH="0"
#!   ATTR_CASE="ANY"
#!   ALLOWED_FEAT_TYPES=""
#!   WRITE_DEFS="true"
#!   DEFLINE_TEMPLATE=""
#!   DEFLINE_ATTRS="true"
#!   EXPOSABLE_ATTRS="fme_geometry fme_char(50) cat_type varchar(64) fme_type varchar(50) fme_primary_axis real64 fme_text_size real64 multi_reader_full_id int32 fme_feature_type varchar(50) fme_dataset varchar(50) cat_line_number int32 multi_reader_keyword varchar(50) fme_start_angle real64 fme_fill_color varchar(50) fme_text_string varchar(50) fme_color varchar(50) fme_basename varchar(50) multi_reader_type varchar(50) fme_secondary_axis real64 fme_rotation real64 multi_reader_id int32 fme_sweep_angle real64"
#!   DEFLINE_PARMS=""
#!   ATTR_INDEX_TYPES=""
#!   ATTR_NAME_INVALID_CHARS=""
#!   SUPPORTS_FEATURE_TYPE_FANOUT="true"
#!   ENABLED="true"
#!   DYNAMIC_FEATURE_TYPES_LIST_ON_MERGE="true"
#!   DATASET_TYPE="FILE"
#!   GENERATE_FME_BUILD_NUM="17280"
#!   MAX_FEATURES=""
#!   COORDSYS=""
#!   FEATURE_TYPES=""
#!   MAX_FEATURES_PER_FEATURE_TYPE=""
#!   START_FEATURE=""
#!   MIN_FEATURES=""
#! >
#! <METAFILE_PARAMETER
#!   NAME="READER_DATASET_HINT"
#!   VALUE="Select the CAT file(s)"
#! />
#! <METAFILE_PARAMETER
#!   NAME="DATASET_NAME"
#!   VALUE="* file"
#! />
#! <METAFILE_PARAMETER
#!   NAME="FEATURE_TYPE_NAME"
#!   VALUE="Text File"
#! />
#! </DATASET>
#! <DATASET
#!   IS_SOURCE="true"
#!   ROLE="READER"
#!   FORMAT="LANDXML"
#!   DATASET="$(SourceDataset_LANDXML)"
#!   KEYWORD="LANDXML_1"
#!   MULTI_GEOM_ALLOWED="false"
#!   ATTR_MAX_LENGTH="0"
#!   ATTR_CASE="ANY"
#!   ALLOWED_FEAT_TYPES=""
#!   WRITE_DEFS="true"
#!   DEFLINE_TEMPLATE="xml_type {FME_GEN_GEOMETRY}"
#!   DEFLINE_ATTRS="true"
#!   EXPOSABLE_ATTRS="landxml_element_id xml_buffer fme_geometry fme_char(50) fme_type xml_char(50) fme_primary_axis xml_real64 fme_text_size xml_real64 multi_reader_full_id xml_int32 landxml_parent_id xml_buffer fme_feature_type xml_char(50) fme_dataset xml_char(50) multi_reader_keyword xml_char(50) landxml_geometry_type xml_char(50) fme_start_angle xml_real64 fme_fill_color xml_char(50) fme_text_string xml_char(50) fme_color xml_char(50) fme_basename xml_char(50) fme_secondary_axis xml_real64 multi_reader_type xml_char(50) landxml_children_id xml_buffer fme_rotation xml_real64 xml_type xml_char(50) multi_reader_id xml_int32 landxml_retwall_offset_above xml_buffer landxml_landxml_type xml_char(18) landxml_retwall_offset_right xml_buffer fme_sweep_angle xml_real64 landxml_equipment_type xml_char(30)"
#!   DEFLINE_PARMS=""
#!   ATTR_INDEX_TYPES=""
#!   ATTR_NAME_INVALID_CHARS=""
#!   SUPPORTS_FEATURE_TYPE_FANOUT="true"
#!   ENABLED="true"
#!   DYNAMIC_FEATURE_TYPES_LIST_ON_MERGE="true"
#!   DATASET_TYPE="FILE"
#!   GENERATE_FME_BUILD_NUM="17280"
#!   MAX_FEATURES=""
#!   COORDSYS=""
#!   FEATURE_TYPES=""
#!   MAX_FEATURES_PER_FEATURE_TYPE=""
#!   START_FEATURE=""
#!   MIN_FEATURES=""
#! >
#! <METAFILE_PARAMETER
#!   NAME="READER_DATASET_HINT"
#!   VALUE="Select the LandXML file(s)"
#! />
#! <METAFILE_PARAMETER
#!   NAME="DATASET_NAME"
#!   VALUE="xml file"
#! />
#! <METAFILE_PARAMETER
#!   NAME="WRITER_DATASET_HINT"
#!   VALUE="Specify a name for the LandXML file"
#! />
#! <METAFILE_PARAMETER
#!   NAME="MIME_TYPE"
#!   VALUE="application/XML"
#! />
#! </DATASET>
#! </DATASETS>
#! <DATA_TYPES>
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="varchar(width)"
#!   FME_TYPE="fme_varchar(width)"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="varchar(width)"
#!   FME_TYPE="fme_varbinary(width)"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="varchar(width)"
#!   FME_TYPE="fme_char(width)"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="varchar(width)"
#!   FME_TYPE="fme_binary(width)"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="varchar(255)"
#!   FME_TYPE="fme_buffer"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="varchar(255)"
#!   FME_TYPE="fme_binarybuffer"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="varchar(255)"
#!   FME_TYPE="fme_xml"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="varchar(255)"
#!   FME_TYPE="fme_json"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="varchar(20)"
#!   FME_TYPE="fme_datetime"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="varchar(12)"
#!   FME_TYPE="fme_time"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="varchar(8)"
#!   FME_TYPE="fme_date"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="real64"
#!   FME_TYPE="fme_real64"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="x_coordinate"
#!   FME_TYPE="fme_real64"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="y_coordinate"
#!   FME_TYPE="fme_real64"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="z_coordinate"
#!   FME_TYPE="fme_real64"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="real64"
#!   FME_TYPE="fme_real32"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="int32"
#!   FME_TYPE="fme_int32"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="real64"
#!   FME_TYPE="fme_uint32"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="varchar(20)"
#!   FME_TYPE="fme_int64"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="varchar(20)"
#!   FME_TYPE="fme_uint64"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="varchar(6)"
#!   FME_TYPE="fme_boolean"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="int32"
#!   FME_TYPE="fme_int16"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="int32"
#!   FME_TYPE="fme_uint16"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="int32"
#!   FME_TYPE="fme_int8"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="int32"
#!   FME_TYPE="fme_uint8"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="real64"
#!   FME_TYPE="fme_decimal(width,decimal)"
#!   FORMAT="CAT"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_char(width)"
#!   FME_TYPE="fme_varchar(width)"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_char(width)"
#!   FME_TYPE="fme_varbinary(width)"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_char(width)"
#!   FME_TYPE="fme_char(width)"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_char(width)"
#!   FME_TYPE="fme_binary(width)"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_buffer"
#!   FME_TYPE="fme_buffer"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_buffer"
#!   FME_TYPE="fme_binarybuffer"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_buffer"
#!   FME_TYPE="fme_json"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_xml"
#!   FME_TYPE="fme_xml"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_datetime"
#!   FME_TYPE="fme_buffer"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_date"
#!   FME_TYPE="fme_buffer"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_time"
#!   FME_TYPE="fme_buffer"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_int64"
#!   FME_TYPE="fme_int64"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_uint64"
#!   FME_TYPE="fme_uint64"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_int32"
#!   FME_TYPE="fme_int32"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_uint32"
#!   FME_TYPE="fme_uint32"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_int16"
#!   FME_TYPE="fme_int16"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_uint16"
#!   FME_TYPE="fme_uint16"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_byte"
#!   FME_TYPE="fme_int8"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_ubyte"
#!   FME_TYPE="fme_uint8"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_real32"
#!   FME_TYPE="fme_real32"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_real64"
#!   FME_TYPE="fme_real64"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_decimal(width,decimal)"
#!   FME_TYPE="fme_decimal(width,decimal)"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_boolean"
#!   FME_TYPE="fme_boolean"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_char(20)"
#!   FME_TYPE="fme_datetime"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_char(8)"
#!   FME_TYPE="fme_date"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_char(12)"
#!   FME_TYPE="fme_time"
#!   FORMAT="LANDXML"
#! />
#! <DATA_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_geometry"
#!   FME_TYPE="fme_buffer"
#!   FORMAT="LANDXML"
#! />
#! </DATA_TYPES>
#! <GEOM_TYPES>
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="cat_none"
#!   FME_TYPE="fme_no_geom"
#!   FORMAT="CAT"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="cat_point"
#!   FME_TYPE="fme_point"
#!   FORMAT="CAT"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="cat_none"
#!   FME_TYPE="fme_point"
#!   FORMAT="CAT"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="cat_none"
#!   FME_TYPE="fme_line"
#!   FORMAT="CAT"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="cat_none"
#!   FME_TYPE="fme_area"
#!   FORMAT="CAT"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="cat_none"
#!   FME_TYPE="fme_text"
#!   FORMAT="CAT"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="cat_none"
#!   FME_TYPE="fme_ellipse"
#!   FORMAT="CAT"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="cat_none"
#!   FME_TYPE="fme_arc"
#!   FORMAT="CAT"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="cat_none"
#!   FME_TYPE="fme_rectangle"
#!   FORMAT="CAT"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="cat_none"
#!   FME_TYPE="fme_rounded_rectangle"
#!   FORMAT="CAT"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="cat_none"
#!   FME_TYPE="fme_collection"
#!   FORMAT="CAT"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="cat_none"
#!   FME_TYPE="fme_surface"
#!   FORMAT="CAT"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="cat_none"
#!   FME_TYPE="fme_solid"
#!   FORMAT="CAT"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="cat_none"
#!   FME_TYPE="fme_raster"
#!   FORMAT="CAT"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="cat_none"
#!   FME_TYPE="fme_point_cloud"
#!   FORMAT="CAT"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="cat_none"
#!   FME_TYPE="fme_feature_table"
#!   FORMAT="CAT"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_no_geom"
#!   FME_TYPE="fme_no_geom"
#!   FORMAT="LANDXML"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_point"
#!   FME_TYPE="fme_point"
#!   FORMAT="LANDXML"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_line"
#!   FME_TYPE="fme_line"
#!   FORMAT="LANDXML"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_area"
#!   FME_TYPE="fme_area"
#!   FORMAT="LANDXML"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_aggregate"
#!   FME_TYPE="fme_collection"
#!   FORMAT="LANDXML"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_text"
#!   FME_TYPE="fme_text"
#!   FORMAT="LANDXML"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_area"
#!   FME_TYPE="fme_ellipse"
#!   FORMAT="LANDXML"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_area"
#!   FME_TYPE="fme_rectangle"
#!   FORMAT="LANDXML"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_area"
#!   FME_TYPE="fme_rounded_rectangle"
#!   FORMAT="LANDXML"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_arc"
#!   FME_TYPE="fme_arc"
#!   FORMAT="LANDXML"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_surface"
#!   FME_TYPE="fme_no_geom"
#!   FORMAT="LANDXML"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_solid"
#!   FME_TYPE="fme_no_geom"
#!   FORMAT="LANDXML"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_mesh"
#!   FME_TYPE="fme_no_geom"
#!   FORMAT="LANDXML"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_raster"
#!   FME_TYPE="fme_no_geom"
#!   FORMAT="LANDXML"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_area"
#!   FME_TYPE="fme_raster"
#!   FORMAT="LANDXML"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_line"
#!   FME_TYPE="fme_surface"
#!   FORMAT="LANDXML"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_line"
#!   FME_TYPE="fme_solid"
#!   FORMAT="LANDXML"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_area"
#!   FME_TYPE="fme_point_cloud"
#!   FORMAT="LANDXML"
#! />
#! <GEOM_TYPE
#!   IS_SOURCE="true"
#!   FORMAT_TYPE="xml_no_geom"
#!   FME_TYPE="fme_feature_table"
#!   FORMAT="LANDXML"
#! />
#! </GEOM_TYPES>
#! <FEATURE_TYPES>
#! <FEATURE_TYPE
#!   IS_SOURCE="true"
#!   NODE_NAME="CAT"
#!   FEATURE_TYPE_NAME=""
#!   FEATURE_TYPE_NAME_QUALIFIER=""
#!   IS_EDITABLE="false"
#!   IDENTIFIER="2"
#!   FEAT_GEOMTYPE="cat_point"
#!   POSITION="100 -230"
#!   BOUNDING_RECT="100 -230 -1 -1"
#!   ORDER="5e+14"
#!   COLLAPSED="true"
#!   KEYWORD="CAT_1"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   HIDDEN_USER_ATTRS=""
#!   MERGE_FILTER=""
#!   MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#!   MERGE_FILTER_CASE_SENSITIVE="true"
#!   DYNAMIC_SCHEMA="false"
#! >
#!     <FEAT_ATTRIBUTE ATTR_NAME="Elementti" ATTR_TYPE="int32" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#!     <FEAT_ATTRIBUTE ATTR_NAME="Nro" ATTR_TYPE="int32" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#!     <FEAT_ATTRIBUTE ATTR_NAME="Koodi" ATTR_TYPE="int32" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#!   IS_SOURCE="true"
#!   NODE_NAME="Surface"
#!   FEATURE_TYPE_NAME=""
#!   FEATURE_TYPE_NAME_QUALIFIER=""
#!   IS_EDITABLE="false"
#!   IDENTIFIER="13"
#!   FEAT_GEOMTYPE="xml_aggregate xml_line"
#!   POSITION="100 -743.004"
#!   BOUNDING_RECT="100 -743.004 -1 -1"
#!   ORDER="5e+14"
#!   COLLAPSED="true"
#!   KEYWORD="LANDXML_1"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   HIDDEN_USER_ATTRS=""
#!   MERGE_FILTER=""
#!   MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#!   MERGE_FILTER_CASE_SENSITIVE="false"
#!   DYNAMIC_SCHEMA="false"
#! >
#!     <FEAT_ATTRIBUTE ATTR_NAME="Desc" ATTR_TYPE="xml_char(21)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#!     <FEAT_ATTRIBUTE ATTR_NAME="Feature{}.Code" ATTR_TYPE="xml_char(8)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#!     <FEAT_ATTRIBUTE ATTR_NAME="Feature{}.Property{}.Label" ATTR_TYPE="xml_char(5)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#!     <FEAT_ATTRIBUTE ATTR_NAME="Feature{}.Property{}.Value" ATTR_TYPE="xml_char(37)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#!     <FEAT_ATTRIBUTE ATTR_NAME="Name" ATTR_TYPE="xml_char(32)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#!     <FEAT_ATTRIBUTE ATTR_NAME="State" ATTR_TYPE="xml_char(9)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#!     <FEAT_ATTRIBUTE ATTR_NAME="landxml_element_id" ATTR_TYPE="xml_decimal(2,0)"  EXPOSABLE_ATTR="true" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#!     <FEAT_ATTRIBUTE ATTR_NAME="landxml_landxml_type" ATTR_TYPE="xml_char(8)"  EXPOSABLE_ATTR="true" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#!     <FEAT_ATTRIBUTE ATTR_NAME="landxml_parent_id" ATTR_TYPE="xml_decimal(2,0)"  EXPOSABLE_ATTR="true" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! </FEATURE_TYPE>
#! </FEATURE_TYPES>
#! <FMESERVER>
#! </FMESERVER>
#! <GLOBAL_PARAMETERS>
#! <GLOBAL_PARAMETER
#!   GUI_LINE="GUI MULTIFILE SourceDataset_CAT All_Files|* Source Column Aligned Text (CAT) File(s):"
#!   DEFAULT_VALUE="$(FME_MF_DIR)Tammitie.lis"
#!   IS_STAND_ALONE="false"
#! />
#! <GLOBAL_PARAMETER
#!   GUI_LINE="GUI MULTIFILE SourceDataset_LANDXML LandXML(*.xml)%*.xml%All_Files%* Source LandXML File(s):"
#!   DEFAULT_VALUE="C:\Users\toomeve\Desktop\työ\Kira OH\201000_Ylin yhdistelmapinta_yyp_tammitie.xml"
#!   IS_STAND_ALONE="false"
#! />
#! </GLOBAL_PARAMETERS>
#! <COMMENTS>
#! </COMMENTS>
#! <CONSTANTS>
#! </CONSTANTS>
#! <BOOKMARKS>
#! </BOOKMARKS>
#! <TRANSFORMERS>
#! <TRANSFORMER
#!   IDENTIFIER="3"
#!   TYPE="LineBuilder"
#!   VERSION="5"
#!   POSITION="777.133 -230"
#!   BOUNDING_RECT="777.133 -230 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="17280"
#! >
#!     <OUTPUT_FEAT NAME="POINT"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="Elementti" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="Nro" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="Koodi" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="LINE"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="Elementti" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="Nro" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="Koodi" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="POLYGON"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="Elementti" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="Nro" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="Koodi" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <OUTPUT_FEAT NAME="&lt;REJECTED&gt;"/>
#!     <FEAT_COLLAPSED COLLAPSED="3"/>
#!     <XFORM_ATTR ATTR_NAME="Elementti" IS_USER_CREATED="false" FEAT_INDEX="3" />
#!     <XFORM_ATTR ATTR_NAME="Nro" IS_USER_CREATED="false" FEAT_INDEX="3" />
#!     <XFORM_ATTR ATTR_NAME="Koodi" IS_USER_CREATED="false" FEAT_INDEX="3" />
#!     <XFORM_ATTR ATTR_NAME="fme_rejection_code" IS_USER_CREATED="false" FEAT_INDEX="3" />
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="LineBuilder"/>
#!     <XFORM_PARM PARM_NAME="LIST_NAME" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="GENERATE_LIST_GROUP" PARM_VALUE="NO"/>
#!     <XFORM_PARM PARM_NAME="LIST_ATTRS_TO_INCLUDE_MODE" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="ACCUM_INPUT_ATTRS" PARM_VALUE="Use Attributes From One Feature"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="BREAKATTR" PARM_VALUE="Elementti"/>
#!     <XFORM_PARM PARM_NAME="LIST_ATTRS_TO_INCLUDE" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="5"
#!   TYPE="AreaBuilder"
#!   VERSION="12"
#!   POSITION="1567.77 -230"
#!   BOUNDING_RECT="1567.77 -230 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="17280"
#! >
#!     <OUTPUT_FEAT NAME="AREA"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="Elementti" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="Nro" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="Koodi" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="Incomplete"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="Elementti" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="Nro" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="Koodi" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="&lt;REJECTED&gt;"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="Elementti" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="Nro" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="Koodi" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="fme_rejection_code" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="FME_PROCESS_GROUPS_ORDERED" PARM_VALUE="No"/>
#!     <XFORM_PARM PARM_NAME="SNAP_TOLERANCE" PARM_VALUE="0.1"/>
#!     <XFORM_PARM PARM_NAME="SNAPTYPE_PARAM" PARM_VALUE="End Point Snapping"/>
#!     <XFORM_PARM PARM_NAME="GROUP_BY" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="POLY_ATTR_ACCUM_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="FME_PROCESS_COUNTDISP" PARM_VALUE="No Parallelism"/>
#!     <XFORM_PARM PARM_NAME="LINES_AS_SEGMENTS" PARM_VALUE="No"/>
#!     <XFORM_PARM PARM_NAME="POLY_LIST_NAME" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="AreaBuilder"/>
#!     <XFORM_PARM PARM_NAME="CONSIDER_NODE_ELEVATION" PARM_VALUE="no"/>
#!     <XFORM_PARM PARM_NAME="ALLOW_CYCLES" PARM_VALUE="No"/>
#!     <XFORM_PARM PARM_NAME="DROP_HOLES" PARM_VALUE="No"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="CONNECT_Z_MODE" PARM_VALUE="First Wins"/>
#!     <XFORM_PARM PARM_NAME="DONUT_CREATION" PARM_VALUE="YES"/>
#!     <XFORM_PARM PARM_NAME="POLY_LIST_ATTRS_TO_INCLUDE_MODE" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="POLY_LIST_ATTRS_TO_INCLUDE" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="SNAP_PARAMETERS_GROUP" PARM_VALUE="FME_DISCLOSURE_OPEN"/>
#!     <XFORM_PARM PARM_NAME="CHECK_CURVE_DIRECTION" PARM_VALUE="No"/>
#!     <XFORM_PARM PARM_NAME="POLY_ACCUM_ATTRS_NAME" PARM_VALUE="Use Attributes From One Feature"/>
#!     <XFORM_PARM PARM_NAME="POLY_GENERATE_LIST_GROUP" PARM_VALUE="NO"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="7"
#!   TYPE="Inspector"
#!   VERSION="4"
#!   POSITION="2121.77 -248.5"
#!   BOUNDING_RECT="2121.77 -248.5 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="false"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="17280"
#! >
#!     <XFORM_PARM PARM_NAME="RASTER_VISUALIZATION_OPTION" PARM_VALUE="No Reduction"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="AreaBuilder_Area"/>
#!     <XFORM_PARM PARM_NAME="RASTER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_MAX_NUM_POINTS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="AREA_COLOR" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="TACKATTRS" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="VECTOR_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PEN_COLOR" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_COL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_ROW" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="THINNER_INTERVAL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="POINTCLOUD_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_COLS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_ROWS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_TYPE_DISPLAY" PARM_VALUE="No Thinning"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="9"
#!   TYPE="Inspector"
#!   VERSION="4"
#!   POSITION="2121.77 -386.5"
#!   BOUNDING_RECT="2121.77 -386.5 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="false"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="17280"
#! >
#!     <XFORM_PARM PARM_NAME="RASTER_VISUALIZATION_OPTION" PARM_VALUE="No Reduction"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="AreaBuilder_Incomplete"/>
#!     <XFORM_PARM PARM_NAME="RASTER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_MAX_NUM_POINTS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="AREA_COLOR" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="TACKATTRS" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="VECTOR_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PEN_COLOR" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_COL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_ROW" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="THINNER_INTERVAL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="POINTCLOUD_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_COLS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_ROWS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_TYPE_DISPLAY" PARM_VALUE="No Thinning"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="11"
#!   TYPE="Inspector"
#!   VERSION="4"
#!   POSITION="2121.77 -524.5"
#!   BOUNDING_RECT="2121.77 -524.5 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="17280"
#! >
#!     <XFORM_PARM PARM_NAME="RASTER_VISUALIZATION_OPTION" PARM_VALUE="No Reduction"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="AreaBuilder__Rejected_"/>
#!     <XFORM_PARM PARM_NAME="RASTER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_MAX_NUM_POINTS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="AREA_COLOR" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="TACKATTRS" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="VECTOR_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PEN_COLOR" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_COL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_ROW" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="THINNER_INTERVAL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="POINTCLOUD_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_COLS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_ROWS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_TYPE_DISPLAY" PARM_VALUE="No Thinning"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="14"
#!   TYPE="Inspector"
#!   VERSION="4"
#!   POSITION="1318.63 -743.004"
#!   BOUNDING_RECT="1318.63 -743.004 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="17280"
#! >
#!     <XFORM_PARM PARM_NAME="RASTER_VISUALIZATION_OPTION" PARM_VALUE="No Reduction"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="Surface"/>
#!     <XFORM_PARM PARM_NAME="RASTER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_MAX_NUM_POINTS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="AREA_COLOR" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="TACKATTRS" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="VECTOR_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PEN_COLOR" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_COL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_START_ROW" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="THINNER_INTERVAL" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="POINTCLOUD_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_COLS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="RASTER_NUM_ROWS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="THINNER_TYPE_DISPLAY" PARM_VALUE="No Thinning"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="16"
#!   TYPE="Deaggregator"
#!   VERSION="10"
#!   POSITION="683.382 -743.004"
#!   BOUNDING_RECT="683.382 -743.004 -1 -1"
#!   ORDER="5e+14"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="17280"
#! >
#!     <OUTPUT_FEAT NAME="DEAGGREGATED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="Desc" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="Feature{}.Code" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="Feature{}.Property{}.Label" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="Feature{}.Property{}.Value" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="Name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="State" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="landxml_element_id" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="landxml_landxml_type" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="landxml_parent_id" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_geometry_name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_PARM PARM_NAME="EXPLODE_INSTANCES" PARM_VALUE="No"/>
#!     <XFORM_PARM PARM_NAME="ID_SELECTION" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="Deaggregator"/>
#!     <XFORM_PARM PARM_NAME="PARENT_ID_ATTR" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PART_NUMBER_FIELD" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="CHILD_ID_ATTR" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="LIST_ATTR" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PRESERVE_HIERARCHY_GROUP" PARM_VALUE="FME_DISCLOSURE_CLOSED"/>
#!     <XFORM_PARM PARM_NAME="MODE" PARM_VALUE="Flatten All Levels"/>
#!     <XFORM_PARM PARM_NAME="GEOM_NAME_FIELD" PARM_VALUE="_geometry_name"/>
#!     <XFORM_PARM PARM_NAME="FLATTEN_ONE_LEVEL_GROUP" PARM_VALUE="FME_DISCLOSURE_OPEN"/>
#!     <XFORM_PARM PARM_NAME="SPLIT_COMPOSITES" PARM_VALUE="No"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="ID_ATTR" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="LIST_ATTR_MODE_LOOKUP" PARM_VALUE="LEAN"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="COPY_ATTR" PARM_VALUE="&lt;Unused&gt;"/>
#! </TRANSFORMER>
#! </TRANSFORMERS>
#! <FEAT_LINKS>
#! <FEAT_LINK
#!   IDENTIFIER="4"
#!   SOURCE_NODE="2"
#!   TARGET_NODE="3"
#!   SOURCE_PORT_DESC="-1"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="17"
#!   SOURCE_NODE="13"
#!   TARGET_NODE="16"
#!   SOURCE_PORT_DESC="-1"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="8"
#!   SOURCE_NODE="5"
#!   TARGET_NODE="7"
#!   SOURCE_PORT_DESC="fo 0 AREA"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="18"
#!   SOURCE_NODE="16"
#!   TARGET_NODE="14"
#!   SOURCE_PORT_DESC="fo 0 DEAGGREGATED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="6"
#!   SOURCE_NODE="3"
#!   TARGET_NODE="5"
#!   SOURCE_PORT_DESC="fo 1 LINE"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="10"
#!   SOURCE_NODE="5"
#!   TARGET_NODE="9"
#!   SOURCE_PORT_DESC="fo 1 Incomplete"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="12"
#!   SOURCE_NODE="5"
#!   TARGET_NODE="11"
#!   SOURCE_PORT_DESC="fo 2 &lt;lt&gt;REJECTED&lt;gt&gt;"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! </FEAT_LINKS>
#! <BREAKPOINTS>
#! </BREAKPOINTS>
#! <ATTR_LINKS>
#! </ATTR_LINKS>
#! <SUBDOCUMENTS>
#! </SUBDOCUMENTS>
#! <LOOKUP_TABLES>
#! </LOOKUP_TABLES>
#! </WORKSPACE>
FME_PYTHON_VERSION 27
GUI IGNORE SourceDataset_CAT_1,CAT_IN_NETWORK_AUTHENTICATION_CAT_1,_SKIP_LINES_CAT_1,LANDXML_IN_EXPOSE_ATTRS_GROUP_LANDXML_1,LANDXML_IN_SEARCH_ENVELOPE_MINX_LANDXML_1,LANDXML_IN_SEARCH_ENVELOPE_MINY_LANDXML_1,LANDXML_IN_SEARCH_ENVELOPE_MAXX_LANDXML_1,LANDXML_IN_SEARCH_ENVELOPE_MAXY_LANDXML_1,LANDXML_IN_SEARCH_ENVELOPE_COORDINATE_SYSTEM_LANDXML_1,LANDXML_IN_CLIP_TO_ENVELOPE_LANDXML_1,SourceDataset_LANDXML_1,LANDXML_IN_NETWORK_AUTHENTICATION_LANDXML_1
DEFAULT_MACRO SourceDataset_CAT $(FME_MF_DIR)Tammitie.lis
GUI MULTIFILE SourceDataset_CAT All_Files|* Source Column Aligned Text (CAT) File(s):
DEFAULT_MACRO SourceDataset_LANDXML C:\Users\toomeve\Desktop\työ\Kira OH\201000_Ylin yhdistelmapinta_yyp_tammitie.xml
GUI MULTIFILE SourceDataset_LANDXML LandXML(*.xml)%*.xml%All_Files%* Source LandXML File(s):
INCLUDE [ if {{$(SourceDataset_CAT)} == {}} { puts_real {Parameter 'SourceDataset_CAT' must be given a value.}; exit 1; }; ]
INCLUDE [ if {{$(SourceDataset_LANDXML)} == {}} { puts_real {Parameter 'SourceDataset_LANDXML' must be given a value.}; exit 1; }; ]
#! START_HEADER
#! START_WB_HEADER
READER_TYPE MULTI_READER
MULTI_READER_TYPE{0} CAT
MULTI_READER_KEYWORD{0} CAT_1
MULTI_READER_GEN_DIRECTIVES{0} _SKIP_LINES,0,_SCHEMA,Elementti<comma>Integer<comma>19<comma>Nro<comma>Integer<comma>9<comma>Koodi<comma>Integer<comma>9<comma>x<comma>Y-Coordinate<comma>13<comma>y<comma>X-Coordinate<comma>13<comma>z<comma>Z-Coordinate<comma>17,ROW_WITH_FIELD_NAMES,0,_MERGE_SCHEMAS,YES,FIELD_NAMES_IN_FILE,NO,_FILTER_VALUE_ENCODED,<lt>Unused<gt>,DUMMY,,_FILTERING,NO,_FILTER_INVERTED,no,_FILTER_FIELD,<lt>Unused<gt>
MULTI_READER_TYPE{1} LANDXML
MULTI_READER_KEYWORD{1} LANDXML_1
MULTI_READER_GEN_DIRECTIVES{1} _MERGE_SCHEMAS,YES,SPLIT_COLLECTIONS,Yes,LANDXML_EXPOSE_FORMAT_ATTRS,,SEARCH_ENVELOPE_COORDINATE_SYSTEM,,EXPOSE_ATTRS_GROUP,,SEARCH_ENVELOPE_MINY,0,SEARCH_ENVELOPE_MINX,0,USE_SEARCH_ENVELOPE,NO,SEARCH_ENVELOPE_MAXX,0,CLIP_TO_ENVELOPE,NO,SEARCH_ENVELOPE_MAXY,0

WRITER_TYPE NULL
WRITER_KEYWORD NULL_DEST
NULL_DEST_DATASET null
#! END_WB_HEADER

#! START_WB_HEADER
MACRO WB_KEYWORD "CAT_1"
#! END_WB_HEADER
#! START_SOURCE_HEADER CAT CAT_1
# ============================================================================
# The following GUI line prompts for files to be used as the
# source of the CAT files.
# The dataset this mapping file was generated from was:
#! END_SOURCE_HEADER
#! START_WB_HEADER
DEFAULT_MACRO SourceDataset
INCLUDE [ if {{$(SourceDataset)} != ""} {                        \
 puts {DEFAULT_MACRO SourceDataset_CAT_1 $(SourceDataset)}     \
 } ]
#! END_WB_HEADER
#! START_SOURCE_HEADER CAT CAT_1
DEFAULT_MACRO SourceDataset_CAT_1 $(SourceDataset_CAT)
GUI MULTIFILE SourceDataset_CAT_1 All_Files|* Source Column Aligned Text (CAT) File(s):
# ============================================================================
# Hardcode the settings that were used to generate this mapping file
#
DEFAULT_MACRO _FILTERING_CAT_1 NO
DEFAULT_MACRO _FILTER_FIELD_CAT_1 <Unused>
DEFAULT_MACRO _FILTER_VALUE_ENCODED_CAT_1 <Unused>
DEFAULT_MACRO _FILTER_INVERTED_CAT_1 no
DEFAULT_MACRO _SKIP_LINES_CAT_1 0
CAT_1_SKIP_LINES $(_SKIP_LINES_CAT_1)
CAT_1_FILTERING $(_FILTERING_CAT_1)
CAT_1_FILTER_FIELD $(_FILTER_FIELD_CAT_1)
CAT_1_FILTER_VALUE_ENCODED $(_FILTER_VALUE_ENCODED_CAT_1)
CAT_1_FILTER_INVERTED $(_FILTER_INVERTED_CAT_1)
CAT_1_SCHEMA Elementti,Integer,19,Nro,Integer,9,Koodi,Integer,9,x,Y-Coordinate,13,y,X-Coordinate,13,z,Z-Coordinate,17
# =====================================================================
# Provide some control over what attributes have the user-selected
# encoding applied. Normally all attributes are updated after being
# read, but the following lines exclude from this treatment all
# attributes whose names start with fme_ or cat_.
CAT_1_UNENCODED_ATTR_PREFIX fme_ cat_
# ===========================================================================
DEFAULT_MACRO CAT_IN_NETWORK_AUTHENTICATION_CAT_1 
CAT_1_NETWORK_AUTHENTICATION "$(CAT_IN_NETWORK_AUTHENTICATION_CAT_1)"
GUI OPTIONAL AUTHENTICATOR CAT_IN_NETWORK_AUTHENTICATION_CAT_1 CONTAINER%GROUP%CONTAINER_TITLE%"Network Authentication"%PROMPT_TYPE%NETWORK Network Authentication
# ===========================================================================
DEFAULT_MACRO CAT_IN_ATTRIBUTE_READING_CAT_1 ALL
CAT_1_ATTRIBUTE_READING "$(CAT_IN_ATTRIBUTE_READING_CAT_1)"
GUI INTEGER _SKIP_LINES_CAT_1 Number of Lines to Skip:
CAT_1_DATASET "$(SourceDataset_CAT_1)"
#! END_SOURCE_HEADER
#! START_WB_HEADER
MACRO WB_KEYWORD "LANDXML_1"
#! END_WB_HEADER
#! START_SOURCE_HEADER LANDXML LANDXML_1
DEFAULT_MACRO LANDXML_IN_SPLIT_COLLECTIONS_LANDXML_1 Yes
LANDXML_1_SPLIT_COLLECTIONS "$(LANDXML_IN_SPLIT_COLLECTIONS_LANDXML_1)"
DEFAULT_MACRO LANDXML_IN_EXPOSE_ATTRS_GROUP_LANDXML_1 
LANDXML_1_EXPOSE_ATTRS_GROUP "$(LANDXML_IN_EXPOSE_ATTRS_GROUP_LANDXML_1)"
GUI DISCLOSUREGROUP LANDXML_IN_EXPOSE_ATTRS_GROUP_LANDXML_1 LANDXML_EXPOSE_FORMAT_ATTRS Schema Attributes
# Include this file in source setting section to add external search envelope processing
# Zero as a default means we don't do any search -- this makes workbench happier
# ===========================================================================
DEFAULT_MACRO LANDXML_IN_SEARCH_ENVELOPE_MINX_LANDXML_1 0
LANDXML_1_SEARCH_ENVELOPE "$(LANDXML_IN_SEARCH_ENVELOPE_MINX_LANDXML_1)"
GUI OPTIONAL FLOAT LANDXML_IN_SEARCH_ENVELOPE_MINX_LANDXML_1 Minimum X:
# ===========================================================================
DEFAULT_MACRO LANDXML_IN_SEARCH_ENVELOPE_MINY_LANDXML_1 0
LANDXML_1_SEARCH_ENVELOPE "$(LANDXML_IN_SEARCH_ENVELOPE_MINY_LANDXML_1)"
GUI OPTIONAL FLOAT LANDXML_IN_SEARCH_ENVELOPE_MINY_LANDXML_1 Minimum Y:
# ===========================================================================
DEFAULT_MACRO LANDXML_IN_SEARCH_ENVELOPE_MAXX_LANDXML_1 0
LANDXML_1_SEARCH_ENVELOPE "$(LANDXML_IN_SEARCH_ENVELOPE_MAXX_LANDXML_1)"
GUI OPTIONAL FLOAT LANDXML_IN_SEARCH_ENVELOPE_MAXX_LANDXML_1 Maximum X:
# ===========================================================================
DEFAULT_MACRO LANDXML_IN_SEARCH_ENVELOPE_MAXY_LANDXML_1 0
LANDXML_1_SEARCH_ENVELOPE "$(LANDXML_IN_SEARCH_ENVELOPE_MAXY_LANDXML_1)"
GUI OPTIONAL FLOAT LANDXML_IN_SEARCH_ENVELOPE_MAXY_LANDXML_1 Maximum Y:
# ===========================================================================
DEFAULT_MACRO LANDXML_IN_SEARCH_ENVELOPE_COORDINATE_SYSTEM_LANDXML_1 
LANDXML_1_SEARCH_ENVELOPE "$(LANDXML_IN_SEARCH_ENVELOPE_COORDINATE_SYSTEM_LANDXML_1)"
GUI OPTIONAL COORDSYS LANDXML_IN_SEARCH_ENVELOPE_COORDINATE_SYSTEM_LANDXML_1 Search Envelope Coordinate System:
# ===========================================================================
# BUG18999: We now have a soft clip to fall back on like native spatial index
# thus we are reintroducing the clip to envelop as an option for users.
# Defualt to soft clip as per the existing database readers we are emulating
DEFAULT_MACRO LANDXML_IN_CLIP_TO_ENVELOPE_LANDXML_1 NO
LANDXML_1_CLIP_TO_ENVELOPE "$(LANDXML_IN_CLIP_TO_ENVELOPE_LANDXML_1)"
GUI OPTIONAL CHECKBOX LANDXML_IN_CLIP_TO_ENVELOPE_LANDXML_1 YES%NO Clip to Search Envelope
# The dataset this mapping file was generated from was:
#! END_SOURCE_HEADER
#! START_WB_HEADER
DEFAULT_MACRO SourceDataset
INCLUDE [ if {{$(SourceDataset)} != ""} {                        \
 puts {DEFAULT_MACRO SourceDataset_LANDXML_1 $(SourceDataset)}     \
 } ]
#! END_WB_HEADER
#! START_SOURCE_HEADER LANDXML LANDXML_1
DEFAULT_MACRO SourceDataset_LANDXML_1 $(SourceDataset_LANDXML)
GUI MULTIFILE SourceDataset_LANDXML_1 LandXML(*.xml)%*.xml%All_Files%* Source LandXML File(s):
# ===========================================================================
DEFAULT_MACRO LANDXML_IN_NETWORK_AUTHENTICATION_LANDXML_1 
LANDXML_1_NETWORK_AUTHENTICATION "$(LANDXML_IN_NETWORK_AUTHENTICATION_LANDXML_1)"
GUI OPTIONAL AUTHENTICATOR LANDXML_IN_NETWORK_AUTHENTICATION_LANDXML_1 CONTAINER%GROUP%CONTAINER_TITLE%"Network Authentication"%PROMPT_TYPE%NETWORK Network Authentication
# ===========================================================================
DEFAULT_MACRO LANDXML_IN_ATTRIBUTE_READING_LANDXML_1 ALL
LANDXML_1_ATTRIBUTE_READING "$(LANDXML_IN_ATTRIBUTE_READING_LANDXML_1)"
LANDXML_1_DATASET "$(SourceDataset_LANDXML_1)"
#! END_SOURCE_HEADER
#! START_WB_HEADER
#! END_WB_HEADER

#! END_HEADER

LOG_FILENAME "$(FME_MF_DIR)mittausdata validonti.log"
LOG_APPEND NO
LOG_MAX_FEATURES 200
LOG_MAX_RECORDED_FEATURES 200
FME_REPROJECTION_ENGINE FME
FME_IMPLICIT_CSMAP_REPROJECTION_MODE Auto
FME_GEOMETRY_HANDLING Enhanced
FME_STROKE_MAX_DEVIATION 0
LOG_FILTER_MASK -1
DEFAULT_MACRO DATASET_KEYWORD_CAT_1 CAT_1
DEFAULT_MACRO DATASET_KEYWORD_LANDXML_1 LANDXML_1
# -------------------------------------------------------------------------

CAT_1_READER_META_ATTRIBUTES fme_feature_type

# -------------------------------------------------------------------------

LANDXML_1_READER_META_ATTRIBUTES fme_feature_type

# -------------------------------------------------------------------------

MULTI_READER_CONTINUE_ON_READER_FAILURE No

# -------------------------------------------------------------------------

MACRO WORKSPACE_NAME mittausdata validonti
MACRO FME_VIEWER_APP fmedatainspector
# -------------------------------------------------------------------------

INCLUDE [ if {[info exists env(FME_TEMP)] && [file isdirectory $env(FME_TEMP)]} {set gVisualizerTemp $env(FME_TEMP)}  elseif {[info exists env(TEMP)] && [file isdirectory $env(TEMP)]}  {set gVisualizerTemp $env(TEMP)}  elseif { $tcl_platform(platform) == "unix" } {set gVisualizerTemp "/tmp"} else {set gVisualizerTemp c:};  regsub -all {[ ,&]} {$(WORKSPACE_NAME)} {_} wsname; set gVisualizerTemp $gVisualizerTemp/${wsname}_[clock format [clock seconds] -format %H%M%S];  puts "MACRO WORKSPACE_TEMP_DIR $gVisualizerTemp"; 
MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/inspector.ffs
MACRO VISUALIZER_SCHEMA_FILE $(WORKSPACE_TEMP_DIR)/inspector.fsc
MACRO VISUALIZER_CREATE_SPATIAL_INDEX YES
# -------------------------------------------------------------------------
CAT_1_DEF CAT   Elementti                    int32   Nro                          int32   Koodi                        int32
# -------------------------------------------------------------------------
LANDXML_1_DEF Surface   xml_type                     "xml_aggregate xml_line"   Desc                         xml_char(21)   Feature{}.Code               xml_char(8)   Feature{}.Property{}.Label   xml_char(5)   Feature{}.Property{}.Value   xml_char(37)   Name                         xml_char(32)   State                        xml_char(9)
# -------------------------------------------------------------------------

FACTORY_DEF * RoutingFactory   FACTORY_NAME "Router and Unexpected Input Remover"   COMMAND_PARM_EVALUATION SINGLE_PASS   INPUT FEATURE_TYPE *    ROUTE CAT CAT_1::CAT multi_reader_keyword,$(DATASET_KEYWORD_CAT_1) TO FME_GENERIC ::CAT ALIAS_GEOMETRY    ROUTE LANDXML LANDXML_1::Surface multi_reader_keyword,$(DATASET_KEYWORD_LANDXML_1) TO FME_GENERIC ::Surface ALIAS_GEOMETRY    MERGE_INPUT Yes   OUTPUT ROUTED FEATURE_TYPE *
CAT_1_MERGE_DEF CAT_1::CAT EXACT CAT
LANDXML_1_MERGE_DEF LANDXML_1::Surface EXACT Surface
# -------------------------------------------------------------------------

FACTORY_DEF * TeeFactory    FACTORY_NAME "CAT (CAT_1) Splitter"    INPUT FEATURE_TYPE CAT    OUTPUT FEATURE_TYPE CAT_CAT_1
# -------------------------------------------------------------------------

FACTORY_DEF * TeeFactory    FACTORY_NAME "Surface (LANDXML_1) Splitter"    INPUT FEATURE_TYPE Surface    OUTPUT FEATURE_TYPE Surface_LANDXML_1
DEFAULT_MACRO WB_CURRENT_CONTEXT
# -------------------------------------------------------------------------

FACTORY_DEF * DeaggregateFactory    FACTORY_NAME Deaggregator    INPUT  FEATURE_TYPE Surface_LANDXML_1    RECURSIVE Yes    SPLIT_COMPOSITES No    INSTANTIATE_GEOMETRY_INSTANCES_NEW No    SET_FME_TYPE Yes    GEOMETRY_NAME_FIELD _geometry_name    OUTPUT POINT FEATURE_TYPE Deaggregator_DEAGGREGATED    OUTPUT LINE FEATURE_TYPE Deaggregator_DEAGGREGATED    OUTPUT POLYGON FEATURE_TYPE Deaggregator_DEAGGREGATED    OUTPUT DONUT FEATURE_TYPE Deaggregator_DEAGGREGATED    OUTPUT AGGREGATE FEATURE_TYPE Deaggregator_DEAGGREGATED

# -------------------------------------------------------------------------

# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Surface} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Surface_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Surface_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Surface_FeatureDirector    INPUT  FEATURE_TYPE Deaggregator_DEAGGREGATED    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Surface___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Surface___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Surface___FeatureDirector1    INPUT FEATURE_TYPE Surface___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Surface___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Surface___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Surface_VectorSetterUpper    INPUT FEATURE_TYPE Surface___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Surface_39829a5a_385c_4f68_800b_0a5783856f111_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Surface___PointCloudThinner    INPUT FEATURE_TYPE Surface___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Surface_39829a5a_385c_4f68_800b_0a5783856f111_thinPointCloud")
Tcl2 proc Surface_39829a5a_385c_4f68_800b_0a5783856f111_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Surface_RasterSetterUpper    INPUT FEATURE_TYPE Surface___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Surface_39829a5a_385c_4f68_800b_0a5783856f111_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Surface_39829a5a_385c_4f68_800b_0a5783856f111_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Surface_39829a5a_385c_4f68_800b_0a5783856f111_VIS_FEAT_TYPE Surface$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Surface_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Surface_39829a5a_385c_4f68_800b_0a5783856f111_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA Desc,varchar<openparen>255<closeparen>,Name,varchar<openparen>255<closeparen>,State,varchar<openparen>255<closeparen>,landxml_element_id,varchar<openparen>255<closeparen>,landxml_landxml_type,varchar<openparen>255<closeparen>,landxml_parent_id,varchar<openparen>255<closeparen>,_geometry_name,varchar<openparen>255<closeparen>    MODE RECORD    STORE_SCANNED_METADATA    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

# -------------------------------------------------------------------------

FACTORY_DEF {*} ConnectionFactory     FACTORY_NAME LineBuilder     INPUT  FEATURE_TYPE CAT_CAT_1     BREAK_BEFORE_FIELD_CHANGE Elementti     ACCUM_INPUT_ATTRS One     LIST_ATTRS_TO_INCLUDE { <Unused> }     LIST_ATTRS_TO_INCLUDE_MODE <Unused>     OUTPUT LINE      FEATURE_TYPE LineBuilder_LINE

# -------------------------------------------------------------------------

FACTORY_DEF * TestFactory    FACTORY_NAME AreaBuilder_GeomFilter_1    INPUT  FEATURE_TYPE LineBuilder_LINE    INPUT FEATURE_TYPE AreaBuilder_GeomFilter_DUMMY    TEST &fme_type == "fme_arc"    TEST &fme_type == "fme_ellipse"    BOOLEAN_OPERATOR OR    OUTPUT PASSED FEATURE_TYPE AreaBuilder___ValidGeoms_1___    OUTPUT FAILED FEATURE_TYPE AreaBuilder___InvalidGeoms_1___
FACTORY_DEF * TestFactory    FACTORY_NAME AreaBuilder_GeomFilter_2    INPUT FEATURE_TYPE AreaBuilder___ValidGeoms_1___    TEST @GlobalVariable(fme_get_mapping_file_flag_keyword_FME_USE_RICH_GEOMETRY) == yes    BOOLEAN_OPERATOR AND    OUTPUT PASSED FEATURE_TYPE AreaBuilder___ValidGeoms___    OUTPUT FAILED FEATURE_TYPE AreaBuilder___InvalidGeoms_1___
FACTORY_DEF * TestFactory    FACTORY_NAME AreaBuilder_GeomFilter_3    INPUT FEATURE_TYPE AreaBuilder___InvalidGeoms_1___    TEST @Tcl2("FME_Coordinates numCoords") >= 2    BOOLEAN_OPERATOR AND    OUTPUT PASSED FEATURE_TYPE AreaBuilder___ValidGeoms___    OUTPUT FAILED FEATURE_TYPE AreaBuilder___InvalidGeoms___
INCLUDE [if { ("END_NODE" == "NONE") || ("0.1" == "0") } {              puts "MACRO AreaBuilder_IS_ENABLE NOT_THIS_TIME";          } else {              puts "MACRO AreaBuilder_IS_ENABLE *";          }          ]
# We skip this step if tolerance is 0
FACTORY_DEF $(AreaBuilder_IS_ENABLE) SnappingFactory    FACTORY_NAME AreaBuilder_SNAPPER    INPUT FEATURE_TYPE AreaBuilder___ValidGeoms___    SNAP_TYPE END_NODE    SNAP_TOLERANCE 0.1    EXTEND_LINES_TO_SNAP NEVER    SAVE_SHORT_LINES No    OUTPUT SNAPPED FEATURE_TYPE AreaBuilder___ValidGeoms___    OUTPUT UNTOUCHED FEATURE_TYPE AreaBuilder___ValidGeoms___
FACTORY_DEF {*} PolygonFactory    FACTORY_NAME AreaBuilder_polygonizer    INPUT FEATURE_TYPE AreaBuilder___ValidGeoms___    CONSIDER_NODE_ELEVATION NO    CONNECT_Z_MODE FIRST_WINS    END_NODED    REPORT_PROGRESS    LIST_ATTRS_TO_INCLUDE  { <Unused> }    LIST_ATTRS_TO_INCLUDE_MODE <Unused>    LINES_AS_SEGMENTS No    ALLOW_CYCLES No    REJECT_INVALID_GEOM Yes    ACCUMMULATE_ATTRIBUTES One    OUTPUT LINE FEATURE_TYPE AreaBuilder_Incomplete    OUTPUT POLYGON FEATURE_TYPE ___POLY___    OUTPUT REJECTED FEATURE_TYPE AreaBuilder_<REJECTED>
INCLUDE [ if { ("YES" == "Yes") || ("YES" == "yes") || ("YES" == "YES") } {              puts "MACRO DONUT_FACTORY_IN {*}";              puts "MACRO TEE_FACTORY_IN NOT_THIS_TIME";          } else {              puts "MACRO DONUT_FACTORY_IN NOT_THIS_TIME";              puts "MACRO TEE_FACTORY_IN *";          }          ]
FACTORY_DEF $(DONUT_FACTORY_IN) DonutFactory    FACTORY_NAME AreaBuilder_donutizer    INPUT FEATURE_TYPE ___POLY___    CONNECT_Z_MODE FIRST_WINS    LINES_AS_SEGMENTS No    DROP_HOLES No    TAG_HOLES NO    SPLIT_INPUT_DONUTS    AREA_BUILDER_HELPER_MODE    MERGE_INCOMING_ATTR YES    ATTR_ACCUM_MODE "One"    LIST_ATTRS_TO_INCLUDE  { <Unused> }    LIST_ATTRS_TO_INCLUDE_MODE <Unused>    MODE COMPLETE    OUTPUT DONUT FEATURE_TYPE AreaBuilder_AREA        @RemoveAttributes(tagged_hole)    OUTPUT POLYGON FEATURE_TYPE AreaBuilder_AREA        @RemoveAttributes(tagged_hole)    OUTPUT REJECTED FEATURE_TYPE AreaBuilder_AREA        @RemoveAttributes(fme_rejection_code)
FACTORY_DEF $(TEE_FACTORY_IN) TeeFactory    FACTORY_NAME AreaBuilder_router    INPUT FEATURE_TYPE ___POLY___    OUTPUT FEATURE_TYPE AreaBuilder_AREA
FACTORY_DEF * TeeFactory    FACTORY_NAME AreaBuilder_WarnInvalids    INPUT FEATURE_TYPE AreaBuilder___InvalidGeoms___    OUTPUT FEATURE_TYPE AreaBuilder_<REJECTED> fme_rejection_code INVALID_GEOMETRY_VERTICES

# -------------------------------------------------------------------------

# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {AreaBuilder__Rejected_} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME AreaBuilder__Rejected__DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME AreaBuilder__Rejected__DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME AreaBuilder__Rejected__FeatureDirector    INPUT  FEATURE_TYPE AreaBuilder_<REJECTED>    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE AreaBuilder__Rejected____NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE AreaBuilder__Rejected____RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME AreaBuilder__Rejected____FeatureDirector1    INPUT FEATURE_TYPE AreaBuilder__Rejected____NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE AreaBuilder__Rejected____VectorFeatures___    OUTPUT PASSED FEATURE_TYPE AreaBuilder__Rejected____PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME AreaBuilder__Rejected__VectorSetterUpper    INPUT FEATURE_TYPE AreaBuilder__Rejected____VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc AreaBuilder__Rejected__392446dc_f87b_4cf4_960e_1e4917fddb6e1_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME AreaBuilder__Rejected____PointCloudThinner    INPUT FEATURE_TYPE AreaBuilder__Rejected____PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("AreaBuilder__Rejected__392446dc_f87b_4cf4_960e_1e4917fddb6e1_thinPointCloud")
Tcl2 proc AreaBuilder__Rejected__392446dc_f87b_4cf4_960e_1e4917fddb6e1_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME AreaBuilder__Rejected__RasterSetterUpper    INPUT FEATURE_TYPE AreaBuilder__Rejected____RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("AreaBuilder__Rejected__392446dc_f87b_4cf4_960e_1e4917fddb6e1_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# AreaBuilder__Rejected__392446dc_f87b_4cf4_960e_1e4917fddb6e1_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO AreaBuilder__Rejected__392446dc_f87b_4cf4_960e_1e4917fddb6e1_VIS_FEAT_TYPE AreaBuilder__Rejected_$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME AreaBuilder__Rejected__Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(AreaBuilder__Rejected__392446dc_f87b_4cf4_960e_1e4917fddb6e1_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA Elementti,varchar<openparen>255<closeparen>,Nro,varchar<openparen>255<closeparen>,Koodi,varchar<openparen>255<closeparen>,fme_rejection_code,varchar<openparen>255<closeparen>    MODE RECORD    STORE_SCANNED_METADATA    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

# -------------------------------------------------------------------------

# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {AreaBuilder_Incomplete} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME AreaBuilder_Incomplete_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME AreaBuilder_Incomplete_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME AreaBuilder_Incomplete_FeatureDirector    INPUT  FEATURE_TYPE AreaBuilder_Incomplete    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE AreaBuilder_Incomplete___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE AreaBuilder_Incomplete___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME AreaBuilder_Incomplete___FeatureDirector1    INPUT FEATURE_TYPE AreaBuilder_Incomplete___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE AreaBuilder_Incomplete___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE AreaBuilder_Incomplete___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME AreaBuilder_Incomplete_VectorSetterUpper    INPUT FEATURE_TYPE AreaBuilder_Incomplete___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc AreaBuilder_Incomplete_43e0f750_1b0f_45aa_8695_a39d72d4f54c1_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME AreaBuilder_Incomplete___PointCloudThinner    INPUT FEATURE_TYPE AreaBuilder_Incomplete___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("AreaBuilder_Incomplete_43e0f750_1b0f_45aa_8695_a39d72d4f54c1_thinPointCloud")
Tcl2 proc AreaBuilder_Incomplete_43e0f750_1b0f_45aa_8695_a39d72d4f54c1_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME AreaBuilder_Incomplete_RasterSetterUpper    INPUT FEATURE_TYPE AreaBuilder_Incomplete___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("AreaBuilder_Incomplete_43e0f750_1b0f_45aa_8695_a39d72d4f54c1_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# AreaBuilder_Incomplete_43e0f750_1b0f_45aa_8695_a39d72d4f54c1_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO AreaBuilder_Incomplete_43e0f750_1b0f_45aa_8695_a39d72d4f54c1_VIS_FEAT_TYPE AreaBuilder_Incomplete$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME AreaBuilder_Incomplete_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(AreaBuilder_Incomplete_43e0f750_1b0f_45aa_8695_a39d72d4f54c1_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA Elementti,varchar<openparen>255<closeparen>,Nro,varchar<openparen>255<closeparen>,Koodi,varchar<openparen>255<closeparen>    MODE RECORD    STORE_SCANNED_METADATA    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

# -------------------------------------------------------------------------

# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {AreaBuilder_Area} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME AreaBuilder_Area_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME AreaBuilder_Area_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME AreaBuilder_Area_FeatureDirector    INPUT  FEATURE_TYPE AreaBuilder_AREA    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE AreaBuilder_Area___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE AreaBuilder_Area___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME AreaBuilder_Area___FeatureDirector1    INPUT FEATURE_TYPE AreaBuilder_Area___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE AreaBuilder_Area___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE AreaBuilder_Area___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME AreaBuilder_Area_VectorSetterUpper    INPUT FEATURE_TYPE AreaBuilder_Area___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc AreaBuilder_Area_c8f23f7d_e4b1_4ad8_9e21_dac0acb39bb91_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME AreaBuilder_Area___PointCloudThinner    INPUT FEATURE_TYPE AreaBuilder_Area___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("AreaBuilder_Area_c8f23f7d_e4b1_4ad8_9e21_dac0acb39bb91_thinPointCloud")
Tcl2 proc AreaBuilder_Area_c8f23f7d_e4b1_4ad8_9e21_dac0acb39bb91_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME AreaBuilder_Area_RasterSetterUpper    INPUT FEATURE_TYPE AreaBuilder_Area___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("AreaBuilder_Area_c8f23f7d_e4b1_4ad8_9e21_dac0acb39bb91_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# AreaBuilder_Area_c8f23f7d_e4b1_4ad8_9e21_dac0acb39bb91_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO AreaBuilder_Area_c8f23f7d_e4b1_4ad8_9e21_dac0acb39bb91_VIS_FEAT_TYPE AreaBuilder_Area$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME AreaBuilder_Area_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(AreaBuilder_Area_c8f23f7d_e4b1_4ad8_9e21_dac0acb39bb91_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA Elementti,varchar<openparen>255<closeparen>,Nro,varchar<openparen>255<closeparen>,Koodi,varchar<openparen>255<closeparen>    MODE RECORD    STORE_SCANNED_METADATA    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

# -------------------------------------------------------------------------

FACTORY_DEF * RoutingFactory FACTORY_NAME "Destination Feature Type Routing Correlator"   COMMAND_PARM_EVALUATION SINGLE_PASS   INPUT FEATURE_TYPE *   FEATURE_TYPE_ATTRIBUTE __wb_out_feat_type__   OUTPUT ROUTED FEATURE_TYPE *    OUTPUT NOT_ROUTED FEATURE_TYPE __nuke_me__ @Tcl2("FME_StatMessage 818059 [FME_GetAttribute fme_template_feature_type] 818060 818061 fme_warn")
# -------------------------------------------------------------------------

FACTORY_DEF * TeeFactory   FACTORY_NAME "Final Output Nuker"   INPUT FEATURE_TYPE __nuke_me__

# -------------------------------------------------------------------------

FACTORY_DEF * CreationFactory   CREATE_AT_END   OUTPUT FEATURE_TYPE __NUKEME__   @TCL("if [file exists {$(WORKSPACE_TEMP_DIR)}] {set files [glob -nocomplain -directory  {$(WORKSPACE_TEMP_DIR)} -tails *.ffs];   if {[llength $files] == 1} {    set theFile {$(WORKSPACE_TEMP_DIR)/};   append theFile [lindex $files 0];   eval FME_Execute System \173\042$(FME_HOME_UNIX)/fmedatainspector\042 --visualizer --single-application --delete-on-close --no-source-prompt -f FFS $theFile & \175;  } elseif { [llength $files] == 0 } {  catch { file delete -force {$(WORKSPACE_TEMP_DIR)} };  } else {  set filesNoExt {}; set lastfile {}; foreach {fileName} [lsort $files] { set fileNoExt [string trimright $fileName {.ffs}]; if [regexp {(.*)_[0-9]*$} $fileNoExt wholething fileNoExtBase] {  if { $fileNoExtBase == $lastfile } { continue } }; set lastfile $fileNoExt; lappend filesNoExt $fileNoExt };  eval FME_Execute System \173\042$(FME_HOME_UNIX)/fmedatainspector\042 --visualizer --single-application --delete-on-close --no-source-prompt -d {$(WORKSPACE_TEMP_DIR)} -a ffs -f FFS $filesNoExt & \175; }; }; ")
FACTORY_DEF * TeeFactory   INPUT FEATURE_TYPE __NUKEME__
